import pyomo.environ as pyo
from pyomo.contrib import appsi
from shapely import Point

from config import settings
from src.models import Demand, Facility, LocationProblem, LocationSolution
from src.models.location_solution import SolutionStatus
from src.services import scale_problem_parameters

TERMINATION_CONDITION_MAPPING = {
    "maxTimeLimit": "Exceeded maximum time limit allowed",
    "maxIterations": "Exceeded maximum number of iterations allowed",
    "minFunctionValue": "Found solution smaller than specified function value",
    "minStepLength": "Step length is smaller than specified limit",
    "globallyOptimal": "Found a globally optimal solution",
    "locallyOptimal": "Found a locally optimal solution",
    "optimal": "Found an optimal solution",
    "maxEvaluations": (
        "Exceeded maximum number of problem evaluations "
        "(e.g., branch and bound nodes)"
    ),
    "other": "Other, uncategorized normal termination",
    "unbounded": "Demonstrated that problem is unbounded",
    "infeasible": "Demonstrated that problem is infeasible",
    "invalidProblem": (
        "The problem setup or characteristics are not valid for the solver"
    ),
    "solverFailure": "Solver failed to terminate correctly",
    "internalSolverError": "Internal solver error",
    "error": "Other error",
    "userInterrupt": "Interrupt signal generated by user",
    "resourceInterrupt": "Interrupt signal in resources used by the solver",
    "licensingProblem": "Problem accessing solver license",
}


def _add_exclusive_region_constraints(
    model, scaled_clients, scaled_fixed_facilities
):
    # Parameters
    number_fixed_facilities = len(scaled_fixed_facilities)

    # Get exclusive regions
    exclusive_regions = [
        (i, facility.exclusive_region)
        for i, facility in enumerate(scaled_fixed_facilities)
        if not facility.exclusive_region.is_empty
    ]
    if exclusive_regions:

        # (5) Do not open facilities in exclusive regions
        model.exclusive_regions_constraints = pyo.ConstraintList()
        for j, client in enumerate(
            scaled_clients, start=number_fixed_facilities
        ):
            regions_containing_client = [
                i
                for i, region in exclusive_regions
                if region.intersects(
                    Point(client.location.to_list(reverse=True))
                )
            ]
            if len(regions_containing_client) > 1:
                intersecting_facilities = [
                    scaled_fixed_facilities[i].name
                    for i in regions_containing_client
                ]
                raise ValueError(
                    "Impossible solve the problem! "
                    "There is an intersection in the exclusive regions "
                    "of the following facilities: "
                    f"{intersecting_facilities}. "
                    "The following coordinates belongs to this "
                    f"intersection: {client.location.to_list()}."
                )
            if len(regions_containing_client) == 1:
                model.exclusive_regions_constraints.add(model.y[j] == 0)

        # (6) Assign clients from exclusive regions
        model.exclusive_regions_assignment_constraints = pyo.ConstraintList()
        for i, region in exclusive_regions:
            clients_in_region = [
                j
                for j, client in enumerate(scaled_clients)
                if region.intersects(
                    Point(client.location.to_list(reverse=True))
                )
            ]
            for j in clients_in_region:
                model.exclusive_regions_assignment_constraints.add(
                    model.x[i, j] == 1
                )


def _add_constraints_for_fixed_facilities(
    model,
    scaled_clients,
    scaled_fixed_facilities,
):
    # Parameters
    number_fixed_facilities = len(scaled_fixed_facilities)
    Ifixed = range(number_fixed_facilities)

    # (4) Fixed facilities are open
    model.fixed_facilities_constraints = pyo.ConstraintList()
    for i in Ifixed:
        model.fixed_facilities_constraints.add(model.y[i] == 1)

    # Exclusive regions are respected
    _add_exclusive_region_constraints(
        model, scaled_clients, scaled_fixed_facilities
    )

    # (7) Maximum facility demand is respected
    model.maximum_facility_demand_constraints = pyo.ConstraintList()
    total_demand = sum(client.demand for client in scaled_clients)
    for i, facility in enumerate(scaled_fixed_facilities):
        max_demand = facility.demand.max or total_demand
        model.maximum_facility_demand_constraints.add(
            sum(
                client.demand * model.x[i, j]
                for j, client in enumerate(scaled_clients)
            )
            <= max_demand
        )

    # (8) Minimum facility demand is respected
    model.minimum_facility_demand_constraints = pyo.ConstraintList()
    for i, facility in enumerate(scaled_fixed_facilities):
        model.minimum_facility_demand_constraints.add(
            sum(
                client.demand * model.x[i, j]
                for j, client in enumerate(scaled_clients)
            )
            >= facility.demand.min
        )


def _build_integer_model(
    location_problem: LocationProblem,
) -> pyo.ConcreteModel:
    """Build the IP model for the Facility Location problem"""

    # Create model for the problem
    model = pyo.ConcreteModel(name="Facility_Location_Problem")

    # Parameters:
    scaled_clients, scaled_fixed_facilities, scaled_cost_matrix = (
        scale_problem_parameters(location_problem=location_problem)
    )
    number_fixed_facilities = len(scaled_fixed_facilities)
    number_clients = len(scaled_clients)

    # Problem sets
    Iset = range(number_fixed_facilities + number_clients)
    Jset = range(number_clients)

    # Decision variables
    model.y = pyo.Var(Iset, within=pyo.Binary)
    model.x = pyo.Var(Iset, Jset, within=pyo.Binary)

    # Objective function: minimize total costs
    model.total_costs = pyo.Objective(
        expr=sum(
            scaled_cost_matrix[i, j] * model.x[i, j]
            for i in Iset
            for j in Jset
        ),
        sense=pyo.minimize,
    )

    # Basic constraints:
    # (1) Total number of facilities to be opened is respected
    number_facilities = (
        number_fixed_facilities + location_problem.number_new_facilities
    )
    model.number_facilities_constraint = pyo.Constraint(
        expr=sum(model.y[i] for i in Iset) == number_facilities
    )

    # (2) Each client at j should be assigned to exactly one facility
    model.client_assignment_constraints = pyo.ConstraintList()
    for j in Jset:
        model.client_assignment_constraints.add(
            sum(model.x[i, j] for i in Iset) == 1
        )

    # (3) if the client is served by facility, then facility is open
    model.open_facility_constraints = pyo.ConstraintList()
    for j in Jset:
        for i in Iset:
            model.open_facility_constraints.add(model.x[i, j] <= model.y[i])

    # Constraints for fixed facilities:
    if number_fixed_facilities > 0:
        _add_constraints_for_fixed_facilities(
            model,
            scaled_clients,
            scaled_fixed_facilities,
        )

    return model


def solve_integer_formulation(
    location_problem: LocationProblem,
) -> LocationSolution:
    """Solve facility location problem via Integer Programming"""

    # Build the integer programming model
    try:
        model = _build_integer_model(location_problem)
    except ValueError as e:
        return LocationSolution(
            status=SolutionStatus.INFEASIBLE,
            message=str(e),
        )

    # Solve the problem using the HiGHS solver
    solver = appsi.solvers.Highs()

    # Set HiGHS solver options
    solver.config.time_limit = location_problem.solver_time_limit_seconds
    solver.config.load_solution = False

    # Solve the problem
    results = solver.solve(model)

    # If the problem was not solved, return infeasible solution
    if results.best_feasible_objective is None:
        return LocationSolution(
            status=SolutionStatus.INFEASIBLE,
            message=TERMINATION_CONDITION_MAPPING.get(
                results.termination_condition.name,
                "Unknown termination condition",
            ),
        )

    # Get the solution status
    solution_status = (
        SolutionStatus.OPTIMAL
        if results.termination_condition
        == appsi.base.TerminationCondition.optimal
        else SolutionStatus.FEASIBLE
    )

    # Load feasible solution into the model
    results.solution_loader.load_vars()

    # Get the new facilities
    new_facilities: list[Facility] = []
    for i, client_i in enumerate(
        location_problem.clients, start=len(location_problem.fixed_facilities)
    ):
        if model.y[i].value == 1:
            expected_demand = sum(
                client_j.demand
                for j, client_j in enumerate(location_problem.clients)
                if model.x[i, j].value == 1
            )
            new_facilities.append(
                Facility(
                    id=f"new_facility_{len(new_facilities) + 1}",
                    name=f"New Facility {len(new_facilities) + 1}",
                    location=client_i.location,
                    demand=Demand(expected=expected_demand),
                )
            )

    # Get clients assigned to fixed facilities and expected demand
    for i, facility in enumerate(location_problem.fixed_facilities):
        facility.demand.expected = sum(
            client.demand
            for j, client in enumerate(location_problem.clients)
            if model.x[i, j].value == 1
        )

    return LocationSolution(
        facilities=new_facilities + location_problem.fixed_facilities,
        total_costs=round(model.total_costs() / settings.SCALE_FACTOR),
        status=solution_status,
        message=TERMINATION_CONDITION_MAPPING.get(
            results.termination_condition.name,
            "Unknown termination condition",
        ),
    )
